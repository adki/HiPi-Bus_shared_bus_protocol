%%%%
%%Title: HiPi+Bus V0.2 Chapter 3
%%Creator: Ando Ki
%%CreationDate: April 1992
%%FileName: sec2
%%RelatedFile: ch3
%%%%%
%%%%%
%\documentstyle[doublespace,a4wide]{hbook}
%\setstretch{1.2}
%\pagestyle{headings}
%\begin{document}
%\pagenumbering{arabic}
%\setcounter{chapter}{1}
%
\section{데이터 전송 버스의 신호선}
\input{ch3/TBL/dtb-signal}
\subsection{어드레스 버스의 신호선 (signal lines of address bus)}
어드레스 버스는 어드레스, 어드레스 영역, 전송의 종류, 전송하고자 하는 데이터의 크기, 어드레스를
구동하는 모듈의 식별자, 각 신호의 패리티, 그리고 어드레스 버스가 구동되고 있음을 알리는 제어신호로
구성된다.
%
\subsubsection{Address : A$<$31..4$>$*}
전송할 데이터의 위치를 알리는 주소이다. 32 비트 중 A$<$31$>$*이
가장 높은 자리수이다.
A$<$3..0$>$* 4개 비트가 없는 대신
16 바이트 이내의 유효 데이터는 BE$<$15..0$>$*에 의해
식별된다.
%
\subsubsection{Address Parity : AP$<$3..0$>$*}
어드레스 신호선의 각 바이트에 해당하는 패리티이다.
AP$<$0$>$*값은 A$<$3..0$>$*의 값을
0x0으로 간주한 상태에서 계산된 값이다.
\input{ch3/TBL/address-parity}
%
\subsubsection{Source Identification : SI$<$7..0$>$*}
어드레스의 구동에 의해서 버스 동작이 시작되며 이 버스 동작은 데이터를 요청하거나 쓰거나 한다.
이때 어드레스 구동과 같은 시간에 해당 SI$<$7..0$>$*를 구동하여 버스 동작을 시작한 모듈을
알린다. 비트 5 - 2에 채워지는 슬롯 어드레스는 해당 슬롯의 GA$<$3..0$>$* 값이고,
비트 1 - 0에 채워지는 값은 해당 보드 내에서 정의한다.
\input{ch3/TBL/source-id}
%
\subsubsection{Source Identification Parity : SIP*}
SI$<$7..0$>$*의 패리티 비트이다.
%
\subsubsection{Address Space : AS$<$2..0$>$*}
어드레스 영역을 구분하기 위한 신호이며 3비트의 신호로 8개의 독립적인 어드레스 영역을 사용할 수 있지만
현재 정의하여 사용하는 것은 메모리 영역, 입출력 영역, 그리고 시스템 영역이고 나머지는 확장을 위해 사용을 유보한다.
각 어드레스 영역은 4GBytes의 크기를 갖는다.
\input{ch3/TBL/address-space}
%
\subsubsection{Transfer Types : TT$<$4..0$>$*}
전송의 종류를 정의하는 신호이다. \\
정의된 데이터 전송은 데이터의 이동 방향에 따라
읽기 전송, 쓰기 전송, 그리고 어드레스 단일 전송으로 구분된다.
읽기 전송은 데이터가 RP에서 RQ로 공급되며, 쓰기 전송은 데이터가 RQ에서 RP로 
공급된다.
어드레스 단일 전송은 데이터의 이동이 없다. \\
각 전송은 이동되는 데이터의 크기에 따라 단일 전송과 블록 전송으로 구분된다.
단일 전송의 경우는 16바이트 경계로 정렬된 어드레스(어드레스를 16로 나누어 나머지가 없는 경우)에서
1-바이트, 또는 연속된 16-바이트 이내의 데이터를 BE$<$15..0$>$*로
지정하여 전송가능하다.
블록 전송의 경우는 64바이트 경계로 정렬된 어드레스(어드레스를 64로 나누어 나머지가 없는 
경우)에서부터 64바이트를 전송가능하다. 이때 BE$<$15..0$>$*는 0xFF로 구동한다.
참고로, 
TT$<$4$>$*는 블록 전송을, TT$<$3$>$*은 쓰기 전송임을 나타낸다.

\input{ch3/TBL/transfer-type}
\begin{itemize}
	\item Normal Read : NRD \\
	단일 전송에 속하며,
	단순히 RP로부터 원하는 데이터를 읽어온다. 이때 해당 데이터는 캐쉬에 저장되지 않는다.
	\item Normal Write : NWR \\
	단일 전송에 속하며,
	단순히 RP로 특정 데이터를 쓴다.
	\item Non-Coherent Read : NCR \\
	단일 전송에 속하며,
	단순히 RP로부터 원하는 데이터를 읽어온다.
	캐쉬 동일성 유지 프로토콜과 전혀 관련이 없는 데이터가 읽혀질 때 사용된다.
	따라서 시스템 내의 모든 캐쉬는 이 전송에 대하여 아무 것도 고려할 것이 없다.
	\item Non-Coherent Write : NCW \\
	단일 전송에 속하며,
	단순히 RP로 특정 데이터를 쓰는 동작으로
	캐쉬 동일성 유지 프로토콜과 전혀 관련이 없는 특정 데이터를 쓸 때 사용한다.
	따라서 시스템 내의 모든 캐쉬는 이 전송에 대하여 아무 것도 고려할 것이 없다.
	\item Invalidation : IVD \\
	어드레스 단일 전송에 속하며,
	캐쉬 동일성 유지 프로토콜을 유지할 책임이 있는 RQ가 자신의 캐쉬에 있는 유효 데이터를
	시스템을 통하여 유일한 유효 데이터로 만들기 위해 캐쉬 동일성 유지 프로토콜을 
	유지할 책임이 있는 다른 RQ들에게 알릴 때 사용한다.
	즉, 다른 캐쉬에 있는 동일 데이터를 무효화시킬 때 사용한다.
	이 전송은 어드레스 기본 사이클만으로 수행된다.
	특히 IVD의 경우 AACK$<$1..0$>$*는 의미를 갖지 않고 대신 SNK*이 사용된다.
	\item Interlock Read : ILR \\
	단일 전송에 속하며,
	잠금동작을 위한 전송으로 이 전송에 의해 잠금이 시작된다.
	NRD와 동일한 버스동작으로 수행되지만 이 전송이 완료된 이후는 해당 영역이 잠금상태가 된다.
	\item Interlock Write : ILW \\
	단일 전송에 속하며,
	잠금동작을 위한 전송으로 이 전송에 의해 잠금이 풀린다.
	NWR와 동일한 버스동작으로 수행되지만 이 전송이 완료된 이후는 해당 영역이 잠금상태에서 풀린다.
	\item Block Read : BRD \\
	블록 전송에 속하며,
	단순히 RP로부터 원하는 데이터를 읽어오며, 이때 해당 데이터는 캐쉬에 저장되지 않는다.
	\item Block Write : BWR \\
	블록 전송에 속하며,
	단순히 RP로 특정 데이터를 쓴다.
	\item Coherent Read : CRD \\
	블록 전송에 속하며,
	캐쉬 동일성 유지 프로토콜을 유지할 책임이 있는 RQ가 데이터를 읽을 때 사용되며,
	읽혀진 데이터가 RQ내의 캐쉬에 저장되어 사용된다. 이때 그 데이타가 전체 시스템을 통하여 유일한
	유효 데이터일 필요는 없다.
	\item Exclusive Read : EXR \\
	블록 전송에 속하며,
	캐쉬 동일성 유지 프로토콜을 유지할 책임이 있는 RQ가 데이터를 읽을 때 사용되며,
	읽혀진 해당 데이터는 전체 시스템을 통하여 유일한 유효 데이터이여야 한다.
	\item Writeback : WRB \\
	블록 전송에 속하며,
	캐쉬 동일성 유지 프로토콜을 유지할 책임이 있는 RQ가 자신의 캐쉬에 있는 유일한 유효 데이터를
	메모리로 또는 메모리와 다른 RQ로 전달할 때 사용한다.
	이때 DI*가 실제 데이터의 종착지를 결정한다. (주의: RQ에서 RQ로만
	데이터가 전달될 때는 ITW를 사용해야만 한다.)
	\item Intervention Write : ITW \\
	블록 전송에 속하며,
	캐쉬 동일성 유지 프로토콜을 유지할 책임이 있는 RQ가 자신의 캐쉬에 있는 유효 데이터를
	다른 특정 RQ에 전달할때 사용한다. 이 전송은 인터벤션이 선행되는 전송이다.
	특히 ITW의 경우 AACK$<$1..0$>$*는 의미를 갖지 않고,
	대신 SNK*가 사용되며, DACK*는 의미를 갖지 않고 CDK*가 사용된다.
\end{itemize}
%
\subsubsection{Address Space and Transfer Types Parity : STP*}
AS$<$2..0$>$*와 TT$<$4..0$>$*를 합한 8 비트에 대한 패리티 비트이다.
%
\subsubsection{Byte Enable : BE$<$15..0$>$*}
단일 전송(NRD, NWR, NCR, NCW, ILR, ILW)때만 유효하며,
1에서 16까지의 연속된 데이터를 지정하는 신호이다.
16 비트의 신호는 데이터 버스의 각 바이트에 대응한다.
블록 전송의 경우 0xFF로 구동한다.
\input{ch3/TBL/byte-enable}
%
\subsubsection{Byte Enable Parity : BEP$<$1..0$>$*}
BE$<$15..0$>$*에 대한 패리티 비트이다.
\input{ch3/TBL/be-parity}
%
\subsubsection{Address Bus Enable : AE*}
현재 진행 중인 주기에서 어드레스 버스의 신호들이 유효한 값을 갖는다는 것을 나타낸다.
%
\subsection{데이터 버스의 신호선 (signal lines of data bus)}
데이터 버스는 데이터, 해당 데이터가 도착해야 하는 모듈(들)의 식별자,
각 신호의 패리티, 그리고 데이터 버스가 구동되고 있음을 알리는 제어신호로
구성된다.
\subsubsection{Data : D$<$127..0$>$*}
128 비트 (16 바이트) 폭의 데이터 신호선이다.
%
\subsubsection{Data Parity : DP$<$15..0$>$*}
데이터 신호선의 각 바이트에 해당하는 패리티이다. 16 바이트 이내의 데이터를
전송할 때 BE$<$15..0$>$*에 의해 지정된 유효한 바이트에 대응하는 패리티는
반드시 정확한 패리티 값을 가져야하고 나머지는 상관하지 않아도 된다.
그러나 가능한 모든 바이트의 패리티가 정확한 값을 갖는 것이 좋다.
\input{ch3/TBL/data-parity}
%
\subsubsection{Destination Identification : DI$<$7..0$>$*}
데이터 버스에 구동되고 있는 데이터가 실제로 어디로 이동하는 것인지를 알리기 위해 사용된다.
메모리 모듈만 지정되는 경우는 RQ에 의해 메모리 쓰기가 수행될 때 사용하며,
이때 비트 5 - 0의 값은 데이터를 구동하는 RQ를 구별하는 정보이다.
특정 RQ만 지정되는 경우는 메모리 읽기에 대한 데이터 응답이나
캐쉬에서 캐쉬로 데이터 이동이 필요할 때 사용하며,
이때 비트 5 - 0의 값은 데이터를 받을 RQ를 구별하는 정보이다.
RQ와 RP가 동시에 지정되는 경우는
비트 7 - 6의 값이 0x3이고 비트 5 - 0의 값은 데이터를 받을 특정 RQ를 구별하는
정보이다.
\input{ch3/TBL/destination-id}
%
\subsubsection{Destination Identification Parity : DIP*}
DI$<$7..0$>$*의 패리티 비트이다.
%
\subsubsection{Data Bus Enable : DE*}
현재 진행 중인 주기에서 데이터 버스의 신호들이 유효한 값을 갖는다는 것을 나타낸다.
%
\subsection{상태 버스의 신호선 (signal lines of status bus)}
상태 버스는 어드레스 전달에 대한 응답, 데이터 전달에 대한 응답, 그리고 캐쉬 동일성 유지
프로토콜에 필요한 제어 신호, 잠금에 대한 응답 신호로 구성된다.
%
\subsubsection{Address Acknowledge : AACK$<$1..0$>$*}
어드레스 전달에 대해 어드레스를 받은 모듈이 그 상태를 알리는 신호이다.
\input{ch3/TBL/aack}
%
\subsubsection{Hit On Shared Line : SHD*}
$RQ_1$에 의해 진행되는 버스 동작에 의해 요청되는 데이터의 유효한 내용을 
자신의 캐쉬에 갖는 $RQ_2$는 SHD* 신호선을 구동하여 $RQ_1$으로하여금
요청되는 데이터가 다른 캐쉬에도 있음을 알린다.
SHD*는 진행 중인 데이터 전송에 아무런 영향을 주지 않으며
단지 다른 캐쉬에 공유되고 있음을 알리는 신호이다.
\input{ch3/TBL/shd}
%
\subsubsection{Hit On Dirty Line : DTY*}
$RQ_1$에 의해 진행되는 버스 동작에 의해 요청되는 데이터의 유효한 값이 메모리에 있지 않고
$RQ_2$의 캐쉬에 있을 때,
자신의 캐쉬에 유일한 유효 데이터를 갖는 $RQ_2$는 DTY* 신호선을 구동하여
$RQ_1$의 진행 중인 데이터 전송을 중지시키고 메모리의 데이터 응답을 방지한다. \\
DTY* 신호가 구동되면 해당 데이터 전송을 수행하는 RQ는 재시도를 해야하고
메모리는 데이터 응답을 하지 않아야 한다.
그리고 DTY* 신호를 구동한 RQ는 자신의 유일한 유효 데이터를 메모리에
반영할 의무를 진다.
\input{ch3/TBL/dty}
%
\subsubsection{Intervention : ITV*}
$RQ_1$에 의해 진행되는 버스 동작에 의해 요청되는 데이터의 유효한 값이 메모리에 있지 않고
$RQ_2$의 캐쉬에 있을 때,
$RQ_2$는 ITV* 신호선을 구동하여 메모리의 데이터
응답을 방지하고 자신이 가지고 있는 유효한 데이터를 $RQ_1$에 공급할 수 있다.
그러나 데이터를 요구한 $RQ_1$은 버스 동작을 계속 진행해야 한다.

ITV* 신호를 구동한 $RQ_2$는 ITW 전송으로
자신의 유일한 유효 데이터를 해당 데이터를 요청한 $RQ_1$에게 전달하거나,
WRB 전송으로 $RQ_1$과 메모리에 동시에 반영할 수 있다.
ITV* 신호에 의해 인터벤션 상태에 있는 $RQ_1$은 전달받은 데이터에 대한 DACK* 대신
CDK*로써 응답한다. 만약 CDK*로 에러의 발생을 알린 경우, ITV* 신호를 받은 $RQ_1$은 요청을
재시도하며, ITV* 신호를 구동했던 $RQ_2$는 전송을 다시 시도하지 않는다.
그러나 $RQ_1$이 CDK*를 오류로 구동했으므로 재시도 할 것이고,
이것에 의해 다시 $RQ_2$가 적절한 동작을 할 수 있다.

이 신호는 캐쉬 동일성 유지 프로토콜을 유지할 책임이 있는 RQ가 현재 요청되는
데이터를 자신의 캐쉬에서 공급하고자 할 때 사용한다. 이 신호가 구동되면 메모리는 데이터를
응답하지 말아야 하며, 이 신호를 구동한 RQ는 반드시 해당 데이터를 공급할 의무를 진다.
\input{ch3/TBL/itv}
%
\subsubsection{Snoop No Acknowledge : SNK*}
캐쉬 동일성 유지 프로토콜을 유지할 책임이 있는 $RQ_1$이 현재 진행 중인
버스 동작이 자신의 캐쉬에 영향을 주는 것인데도 불구하고 자신이 이에 합당한 캐쉬 동작을
할 수 없거나 또는 진행 중인 버스 동작에 관련된 자신의 캐쉬 동작에 문제가 발생한 경우
해당 버스 동작을 더 이상 진행되지 못하도록 하기 위해 구동한다.
SNK* 신호가 구동되면 해당 데이터 전송을 수행하는 $RQ_2$는 재시도를 해야하고
메모리는 데이터 응답을 하지 않아야 한다.
\input{ch3/TBL/snk}
%
\subsubsection{Hit On Interlocked Region : LCR*}
진행되는 버스 동작에 의해 요청되는 영역이 잠겨 있음을 알린다.
$RQ_1$에 의해 진행되는 잠금동작과 관련되어서 아직 완료되기 이전에
참조하여서는 안되는 영역에 대해 $RQ_2$에 의해 참조가 시도되는 경우 
$RQ_1$은 LCR* 신호를 구동하여 $RQ_2$로 하여금 진행하고자 하는
전송이 잠금과 관련된 것임을 알린다. \\
LCR* 신호가 구동되면 해당 데이터 전송을 수행하는 $RQ_2$는 재시도를 해야하고
메모리는 데이터 응답을 하지 않아야 한다.
\input{ch3/TBL/lcr}
%
\subsubsection{Spin Queue Order : SPIN$<$3..0$>$*}
스핀(spin) 상태인 세마포 캐쉬(semaphore cache)의 대기 순서.
%
\subsubsection{Data Acknowledge : DACK*}
데이터 전달에 대해 데이터를 받은 모듈이 전달된 데이타의 상태를 알리는 신호이다.
DACK*는 읽기와 쓰기에 모두 사용된다. 읽기의 경우 RP에서 받은 데이터에 문제가
있을 때 RQ는 DACK*을 error로 구동하고 해당 전송을 처음부터 재시도한다.
쓰기의 경우에도 DACK*을 error로 받으면 해당 전송을 처음부터 재시도한다.
\input{ch3/TBL/dack}
%
\subsubsection{Cache Data Acknowledge : CDK*}
$RQ_1$에서 $RQ_2$로 데이터 전송이 이루어지는 ITW 전송에서,
전달되는 데이터에 대한 응답으로 $RQ_2$가 구동하고 $RQ_1$이 확인하는 신호이다.
그리고 CDK*에서 에러가 구동된 경우, 받는 쪽인 $RQ_2$는 요청을 재시도하며,
전송측인 $RQ_1$은 ITW 전송을 재시도하지 않는다. (CDK*의 값에 관계없이
$RQ_1$은 자발적으로 재시도해서는 안된다. 즉 CDK*가 오류로 구동된 경우에도
$RQ_2$가 재시도하기 때문이다.)
\input{ch3/TBL/cdk}
%
\subsubsection{Busy Status Line : BSY$<$7..0$>$*}
보드간 낮은차 인터리빙(low-order interleaving among boards)된
각 RP들은 자신의 상태에 따라 해당 BSY$<$n$>$* 신호을 구동할 수 있다.
예로써, 8-way 인터리빙된 8장의 RP가 있다면 자신에게 할당되는 어드레스 영역이
주어진 어드레스를 8로 나누었을때 나머지에 따라 결정된다 (단 각 RP의 응답 크기에
해당하는 오프셋은 고려한 어드레스를 8로 나눈다).
나머지가 0인 경우 선택되는 RP는 BSY$<$0$>$*,
나머지가 1인 경우 선택되는 RP는 BSY$<$1$>$*, $\cdots$,
나머지가 7인 경우 선택되는 RP는 BSY$<$7$>$*을 구동함으로써
해당 어드레스에 대한 요청이 RP에 의해 받아들여지지 못하고 AACK$<$1..0$>$*을
busy로 받게 될 것임을 알리는 것이다. \\
RQ는 자신이 요청할 어드레스와 관련이 있는 BSY$<$n$>$* 신호가
구동된 경우에는 요청을 유보할 수 있다.
%%%%%
%\end{document}
%%%%%
